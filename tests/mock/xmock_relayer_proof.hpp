
#pragma once
#include <vector>
#include "xevm_common/common_data.h"
#include "xevm_common/xborsh.hpp"

#include "xmock_relayer_header.hpp"

typedef struct MerklePathItem {
    h256     hash;
    uint8_t         direction; 
}x_MerklePathItem;

typedef struct MerklePath {
    x_MerklePathItem[] items;
}x_MerklePath;


typedef struct ExecutionStatus {
    uint8_t enumIndex;
    bool unknown;
    bool failed;
    bytes successValue;        // The final action succeeded and returned some value or an empty vec.
    h256 successReceiptId; // The final action of the receipt returned a promise or the signed transaction was converted to a receipt. Contains the receipt_id of the generated receipt.
}x_ExecutionStatus;

typedef struct ExecutionOutcome {
   // bytes[] logs; // Logs from this transaction or receipt.
    h256                receipt_ids;
    std::vector<h256>   receipt_ids;        // Receipt IDs generated by this transaction or receipt.
    uint64_t            gas_burnt;          // The amount of the gas burnt by the given transaction or receipt.
    u128                tokens_burn t;      // The total number of the tokens burnt by the given transaction or receipt.
    bytes               executor_id;        // Hash of the transaction or receipt id that produced this outcome.
    ExecutionStatus     status;             // Execution status. Contains the result in case of successful execution.
    std::vector<h256>   merkelization_hashes;
}x_ExecutionOutcome;


typedef struct ExecutionOutcomeWithId {
    h256                id; // The transaction hash or the receipt ID.
    x_ExecutionOutcome  outcome;
    h256                hash;
}x_ExecutionOutcomeWithId;

typedef struct ExecutionOutcomeWithIdAndProof {
    x_MerklePath            proof;
    h256                    block_hash;
    ExecutionOutcomeWithId  outcome_with_id;
}x_ExecutionOutcomeWithIdAndProof;


struct FullOutcomeProof {
    x_ExecutionOutcomeWithIdAndProof outcome_proof;
    MerklePath outcome_root_proof; // TODO: now empty array
    x_LightClientBlockInnerHeader block_header_lite;
    MerklePath block_proof;
}

